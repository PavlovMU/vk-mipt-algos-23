'''
Требуется найти количество бинарных последовательностей длины N, где 3 единицы не стоят подряд.

Заводим массив dp. В каждую ячейку массива записываем количество вариантов на шаге с номером индекса
этой ячейки. Инициализация: dp = [0, 2, 4, 7] (легко посчитать руками). Рассмотрим N-й шаг:
на этом шаге мы можем записать в конец 0 или 1, причем, мы должны быть уверены, что это не "сломает"
нашу последовательность. В этом можно убедиться следующим образом:
1) если мы к корректной последовательности длинной N-1 прибавим в конец 0, 
то мы ТОЧНО ничего не сломаем (если прибавим один, может получиться ...111)
2) если мы к корректной последовательности длинной Т-2 прибавим в конец 01, 
то мы точно ничего не сломаем (если прибавим 11, может получиться ...111, 
не рассматриваем 10, потому что прибавление 0 в конце уже рассмотрели в предыдущем пункте)
3) если мы к корректной последовательности длинной N-2 прибавим в конце 011,
то мы ТОЧНО ничего не сломаем.

Таким образом, нам нужно сложить количество способов, которыми мы можем получить последовательности
соответствующих длин (получили числа трибоначи).
'''

def foo(n: int) -> int:
    dp = [0, 2, 4, 7]

    if n <= 3:
        return dp[n]
    
    for i in range(4, n+1):
        dp.append(dp[i-3] + dp[i-2] + dp[i-1])

    return dp[n]

# Let's try to make a little memory optimisation
def add_val_to_list(dp: list, val: int) -> list:
    dp = dp[1:4] + [val]
    return dp

def improved_foo(n: int) -> int:
    dp = [0, 2, 4, 7]

    if n <= 3:
        return dp[n]
    
    for i in range(4, n+1):
        dp = add_val_to_list(dp, dp[i-3] + dp[i-2] + dp[i-1])

    return dp[-1]

def main():
    N = int(input())
    print(foo(N))
    # print(improved_foo(N))

if __name__ == '__main__':
    main()